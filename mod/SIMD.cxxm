export module SIMD;

export namespace simd {

#ifdef __x86_64__
#ifdef __AVX512F__
inline constexpr long REGISTERS = 32;
inline constexpr long VECTORWIDTH = 64;
#else // not __AVX512F__
inline constexpr long REGISTERS = 16;
#ifdef __AVX__
inline constexpr long VECTORWIDTH = 32;
#else  // no AVX
inline constexpr long VECTORWIDTH = 16;
#endif // no AVX
#endif
#else  // not __x86_64__
inline constexpr long REGISTERS = 32;
inline constexpr long VECTORWIDTH = 16;
#endif // __x86_64__

template <typename T, long W = VECTORWIDTH / sizeof(T)>
using Vec = T __attribute__((ext_vector_type(W)));

template <typename T, long W = VECTORWIDTH / sizeof(T)>
constexpr auto load(const T *p) -> Vec<T, W> {
  return *reinterpret_cast<const Vec<T, W> *>(p);
}
template <typename T, long W> constexpr void store(T *p, Vec<T, W> v) {
  *reinterpret_cast<Vec<T, W> *>(p) = v;
}

template <typename T, long W> struct SIMDPair {
  Vec<T, W> lo_, hi_;
};
template <typename T, long W>
[[gnu::always_inline]] constexpr auto split(Vec<T, W> x) -> SIMDPair<T, W / 2> {
  if constexpr (W == 2) {
    return {x[0], x[1]};
  } else if constexpr (W == 4) {
    return {__builtin_shufflevector(x, x, 0, 1),
            __builtin_shufflevector(x, x, 2, 3)};
  } else if constexpr (W == 8) {
    return {__builtin_shufflevector(x, x, 0, 1, 2, 3),
            __builtin_shufflevector(x, x, 4, 5, 6, 7)};
  } else if constexpr (W == 16) {
    return {__builtin_shufflevector(x, x, 0, 1, 2, 3, 4, 5, 6, 7),
            __builtin_shufflevector(x, x, 8, 9, 10, 11, 12, 13, 14, 15)};
  }
  static_assert(false, "unsupported");
}

template <typename T, long W>
[[gnu::always_inline]] constexpr auto sum(Vec<T, W> x) -> T {
  if constexpr (W > 2) {
    SIMDPair<T, W / 2> s = split(x);
    return sum(s.lo_ + s.hi_);
  } else
    return x[0] + x[1];
}

} // namespace simd
